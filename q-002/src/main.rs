// -*- coding:utf-8-unix -*-

use proconio::input;

fn main() {
    input! {
        n: usize,
    }

    // // 奇数の場合、正しい組み合わせが存在しないので終了する
    if n % 2 == 1 {
        return;
    }

    // これは bit 全探索で解ける
    // "(" の場合を 0、 ")" の場合を 1 と見なして全探索していく

    // 正しいカッコ列が "(" と ")" の二種類しかなく、
    // 長さが n であることを考えると、 2^n 通りのカッコ列を調べれば良い
    // << でビット（2進数）を n 個分左へシフトし、2^n 回のループを回す
    // つまり、n が 4 の場合は 2^4 = 16 となり、 `0..16` と書いているのと同義になる
    for i in 0..(1 << n) {
        let mut cnt = 0;

        // 長さは n なので、n 個分の値を取り出して検証する
        for j in 0..n {
            // 正しいカッコ列にするには "(" ではじまり ")" で終わる必要がある
            // ")" の場合はマイナス、"(" の場合はプラスしていき、最終的に 0 になるものは正しい並びであるといえる
            // これは競プロの問題における典型知識である

            // >> でビット（2進数）を n 個分右へシフトする
            // `&` は AND 演算を行う演算子である
            // `i >> (n - j - 1) & 1` をすることで、
            // 10 進数を 2 進数に置き換えた後、先頭の位から順に 0 か 1 かを判定する、という処理が行える
            // 0 ならば "(" 、1 ならば ")" と判定する
            if (i >> (n - j - 1)) & 1 == 1 {
                cnt -= 1;
                // 途中で 0 を下回るケースは正しい並びではない
                if cnt < 0 {
                    break;
                }
            } else {
                cnt += 1;
            }
        }

        // 最終的に 0 になるものは正しいカッコ列のため、print する
        // 10 進数を 2 進数に置き換えた後、先頭の位から順に 0 か 1 かを判定する
        // 0 ならば "(" 、1 ならば ")" と判定する
        if cnt == 0 {
            println!(
                "{}",
                (0..n)
                    .collect::<Vec<usize>>()
                    .iter()
                    .map(|&j| if (i >> (n - j - 1)) & 1 == 0 {
                        "("
                    } else {
                        ")"
                    })
                    .collect::<String>()
            );
        }
    }
}
